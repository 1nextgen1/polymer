<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>

  /*
    Process inputs efficiently via a configure lifecycle callback.
    Configure is called top-down, host before local dom. Users should 
    implement configure to supply a set of default values for the element by 
    returning an object containing the properties and values to set.

    During configuration user change handlers are deferred. When an element 
    becomes ready, change handlers are run. This ensures
    that any user change handlers are not called before ready time.
  */

  /*
  Implementation notes:

  Configured values are set and propagate down the tree. Configured values are
  set only iff there is no existing value. This avoids 
  (1) defaults stomping on inputs and, (2) spamming the tree with
  data changes. All change handlers are deferred until ready time when they 
  are called in order.

  Events can be heard before an element is ready. This may occur when
  a user sends an event in a change handler or listens to a data event
  directly (on-foo-changed).

  */

  using(['Base', 'bind'], function(Base, Bind) {

    Bind.addBuilders({

      method: function(model, source, effect) {
        return 'this._dispatchMethod(\'' + effect + '\', this._data.' + source + ', old);'
      }
    });

    Base.addFeature({

      _setupConfigure: function() {
        this._changes = [];
      },

      _configure: function() {
        var d$ = this.configure();
        // set the value iff it is not already set
        // do *not* run change handlers
        for (var d in d$) {
          if (!(d in this._data)) {
            this[d] = d$[d];
          }
        }
      },

      // if `_readied` is set, call the change handler immediately,
      // otherwise queue it for calling when the element is ready.
      _dispatchMethod: function(effect, value, old) {
        if (this._readied) {
          var method = this[effect];
          if (method) {
            method.call(this, value, old);
          }
        } else {
          this._queueChange(effect, value, old);
        }
      },

      _queueChange: function(effect, value, old) {
        this._changes.push([effect, value, old]);
      },

      // turn on normal change processing
      // and run any queued change handlers.
      _takeChanges: function() {
        var e$ = this._changes;
        if (e$) {
          for (var i=0, l=e$.length, e; (i<l) && (e=e$[i]); i++) {
            this._dispatchMethod(e[0], e[1], e[2]);
          }
        }
        this._changes = [];
      },

      // process change queue and turn on normal change processing
      // just before ready (bottom-up)
      _beforeReady: function() {
        this._takeChanges();
      }

    });

  });

</script>