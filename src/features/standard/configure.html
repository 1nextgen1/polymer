<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<script>


  using(['Base', 'bind'], function(Base, Bind) {

    // TODO(sjmiles): note 'true' argument at the bottom causing this feature
    // to be inserted at the top of the features list. This was a quick-fix.

    // TODO(sorvell): questionable...
    // change `method` builder to use an indirection
    Bind.addBuilders({

      method: function(model, source, effect) {
        return 'this._dispatchMethod(\'' + effect + '\', this._data.' + source + ', old);'
      }
    });

    Base.addFeature({

      // prototyping

      _setupConfigure: function() {
        this._changes = [];
      },

      _configure: function() {
        var d$ = this._defaults = this.configure();
        for (var d in d$) {
          this.setDefaultValue(d, d$[d]);
        }
      },

      _ready: function() {
        this._readied = true;
        this._takeChanges();
        this.ready();
      },

      isDefaultChangeProperty: function(property) {
        return this.getPublishInfo(property).defaultChange;
      },

      // set the value iff it is not already set
      // do *not* run change handlers
      setDefaultValue: function(property, value) {
        if (!this.hasValue(property)) {
          var o = this._abortChanges;
          if (!this.isDefaultChangeProperty(property)) {
            this._abortChanges = true;
          }
          this[property] = value;
          this._abortChanges = o;
        }
      },

      // a value has been set for the given property
      hasValue: function(property) {
        return (property in this._data);
      },

      // the value of the given property is the default value.
      hasDefaultValue: function(property) {
        return (this._data[property] === this._defaults[property]);
      },

      // make sure to process the change handler for the given property
      // even if only the default value has been set.
      ensureChangeHandler: function(property) {
        if (this.hasDefaultValue(property)) {
          // call property change handler...
          var n = this._changeHandlerForProperty(property);
          var m = this[n];
          if (m) {
            m.call(this, this[property]);
          }
        }
      },

      // TODO(sorvell): shouldn't use bind directly.
      _changeHandlerForProperty: function(property) {
        return this.bind[property];
      },

      // helper called by property effectors which provides an 
      // indirection for processing user change handlers.
      // if `_abortChanges` is set, the change is aborted
      // if `_readied` is set, call the change handler immediately,
      // otherwise queue it for calling when the element is ready.
      _dispatchMethod: function(effect, value, old) {
        if (!this._abortChanges) {
          if (this._readied) {
            var method = this[effect];
            if (method) {
              method.call(this, value, old);
            }
          } else {
            this._queueChange(effect, value, old);
          }
        }
      },

      // TODO(sorvell): push iff not in stack already?
      _queueChange: function(effect, value, old) {
        this._changes.push([effect, value, old]);
      },

      // turn on normal change processing
      // and run any queued change handlers.
      // TODO(sorvell): decide if we want to collapse multiple calls to the 
      // same change handler.
      _takeChanges: function() {
        var e$ = this._changes;
        if (e$) {
          for (var i=0, l=e$.length, e; (i<l) && (e=e$[i]); i++) {
            this._dispatchMethod.apply(this, e);
          }
        }
        this._changes = [];
      },

      // process change queue and turn on normal change processing
      // just before ready (bottom-up)
      _beforeReady: function() {
        this._takeChanges();
      }

    }, true);

  });

</script>
